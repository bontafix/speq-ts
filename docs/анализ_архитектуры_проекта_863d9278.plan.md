---
name: Анализ архитектуры проекта
overview: Комплексный анализ архитектуры Node.js/TypeScript проекта speq-ts с выявлением дублирования кода, избыточных зависимостей и рекомендациями по рефакторингу. Отчёт включает подробный анализ всех модулей и краткую версию с основными проблемами.
todos:
  - id: detailed-report
    content: Создать подробный отчёт с полным анализом всех модулей, диаграммами архитектуры и детальными рекомендациями
    status: completed
  - id: quick-summary
    content: Создать краткую версию отчёта (1-2 страницы) с основными проблемами и способами решения
    status: completed
  - id: priority-list
    content: Составить приоритизированный список задач рефакторинга с оценкой времени
    status: completed
  - id: diagrams
    content: "Добавить диаграммы: архитектура проекта, поток данных, модульные зависимости"
    status: cancelled
isProject: false
---

# План отчёта по анализу архитектуры проекта speq-ts

## 1. Обзор проекта

### Общая структура

- **Назначение**: Telegram-бот для поиска строительного оборудования с AI-ассистентом
- **Основные компоненты**:
  - REST API ([src/api/](src/api/)) — Fastify сервер с JWT авторизацией
  - Telegram Bot ([src/telegram/](src/telegram/)) — интеграция с Telegram через webhooks/polling
  - LLM интеграция ([src/llm/](src/llm/)) — работа с Groq, Ollama, OpenAI
  - Search Engine ([src/search/](src/search/)) — гибридный поиск (FTS + Vector)
  - Нормализация ([src/normalization/](src/normalization/)) — обработка параметров оборудования
  - База данных PostgreSQL с pgvector для семантического поиска

### Технологический стек

- **Runtime**: Node.js с TypeScript
- **Web Framework**: Fastify 5.x с плагинами (@fastify/cors, @fastify/jwt, @fastify/swagger)
- **Database**: PostgreSQL (через pg 8.x) с расширением pgvector
- **Bot Framework**: Telegraf 4.x
- **LLM Providers**: groq-sdk, нативные HTTP-клиенты для Ollama/OpenAI
- **Утилиты**: sharp (обработка изображений), bcrypt, jsonwebtoken
- **Dev Tools**: ts-node, nodemon, concurrently, PM2 (ecosystem.config.js)

## 2. Детальный анализ модулей

### 2.1. API модуль (src/api/)

**Структура**:

```
api/
├── core/ — ядро (database, plugins, errors, schemas)
├── modules/ — бизнес-модули (auth, brands, categories, equipment, users, etc.)
├── shared/ — общие утилиты (api-response, password, jwt)
└── server.ts — точка входа
```

**Паттерны**:

- Модульная архитектура: controller → service → database
- JSON Schema валидация через Fastify schemas
- JWT авторизация через декоратор `@Auth()`
- Единообразный формат ответов через `sendSuccess()`

**Проблемы**:

1. Дублирование password.ts:

   - [src/api/shared/lib/password.ts](src/api/shared/lib/password.ts) (используется)
   - [src/api/shared/utils/password.ts](src/api/shared/utils/password.ts) (НЕ используется, 100% дублирование)

2. Преобразование дат (99 вхождений в 6 файлах):
   ```typescript
   const createdAt = row.created_at instanceof Date 
     ? row.created_at.toISOString() 
     : new Date(row.created_at).toISOString();
   ```


Дублируется в: `brand.service.ts`, `category.service.ts`, `equipment.service.ts`, `user.service.ts`, `parameter-dictionary.service.ts`, `auth.service.ts`

3. Валидация ID (24 вхождения в 3 контроллерах):
   ```typescript
   const userId = parseInt(id, 10);
   if (isNaN(userId)) throw new Error("Invalid user ID");
   ```

4. Логика пагинации (дублируется в 3 сервисах):
   ```typescript
   const safePage = page > 0 ? page : 1;
   const safeLimit = limit > 0 ? limit : 20;
   const offset = (safePage - 1) * safeLimit;
   ```

5. Динамическое построение UPDATE-запросов (дублируется в 4 сервисах):
   ```typescript
   const updates: string[] = [];
   const values: any[] = [];
   let paramIndex = 1;
   if (data.field !== undefined) {
     updates.push(`field = $${paramIndex++}`);
     values.push(data.field);
   }
   ```


### 2.2. База данных (src/db/ и src/api/core/database/)

**Проблема: Два независимых пула подключений**:

1. [src/db/pg.ts](src/db/pg.ts) — `pgPool` (используется скриптами, Telegram ботом, CLI)

   - Параметры из `process.env` напрямую
   - max: 20 соединений

2. [src/api/core/database/pool.ts](src/api/core/database/pool.ts) — `fastify.db` (используется API)

   - Параметры через `ConfigService`
   - max: 20 соединений

**Последствия**:

- Риск создания до 40 соединений одновременно
- Дублирование логики создания пула (100+ строк)
- Дублирование функции `checkDatabaseHealth()`:
  - [src/db/pg.ts](src/db/pg.ts) (без параметров, использует pgPool)
  - [src/api/core/database/health.ts](src/api/core/database/health.ts) (принимает pool)

**Repository Pattern**:

- Только один репозиторий: [src/repository/equipment.repository.ts](src/repository/equipment.repository.ts)
- Проблема: импортирует `pgPool` напрямую вместо DI
- Остальные модули работают через `fastify.db.query()` без репозиториев

### 2.3. Нормализация параметров (src/normalization/)

**Структура**:

- `parameter-dictionary.service.ts` — загрузка словаря из БД (read-only кэш)
- `parameter-normalizer.service.ts` — нормализация raw-параметров
- `query-parameter-normalizer.ts` — нормализация SearchQuery от LLM
- `unit-parser.ts` — конверсия единиц измерения
- `enum-mapper.ts` — маппинг enum-значений
- `parameter-name-mapper.ts` — **УСТАРЕВШИЙ** hardcoded fallback

**Проблемы**:

1. Дублирование интерфейса `ParameterDictionary`:

   - [src/normalization/parameter-dictionary.service.ts](src/normalization/parameter-dictionary.service.ts) — snake_case формат
   - [src/api/modules/parameter-dictionary/parameter-dictionary.service.ts](src/api/modules/parameter-dictionary/parameter-dictionary.service.ts) — camelCase формат
   - Разные наборы полей, нет переиспользования

2. Избыточный код: `ParameterNameMapper` (~154 строки)

   - Дублирует функционал словаря из БД
   - Используется только в тестовом скрипте `test-parameter-search.ts`
   - Можно удалить после проверки покрытия словарём

3. Неоптимальный поиск в `findCanonicalKey()`:

   - Линейный поиск O(n) по всему словарю
   - Нет HashMap-индексов для O(1) поиска

4. Отсутствие глобального кэша словаря:

   - Каждый экземпляр загружает словарь отдельно
   - Множественные запросы к БД при создании экземпляров

### 2.4. LLM интеграция (src/llm/)

**Структура**:

```
llm/
├── providers/
│   ├── llm-provider.interface.ts — интерфейс
│   ├── groq.provider.ts — через groq-sdk
│   ├── ollama.provider.ts — нативный HTTP
│   ├── openai.provider.ts — нативный HTTPS
│   └── provider.factory.ts — фабрика с fallback
├── ollama.client.ts — **УСТАРЕВШИЙ** (deprecated)
├── answer.generator.ts — форматирование результатов
├── question.parser.ts — парсинг через LLM (возможно не используется)
├── search-query.validator.ts — валидация SearchQuery
└── interactive-query.builder.ts — диалоговый парсинг
```

**Проблемы**:

1. Устаревший код: [src/llm/ollama.client.ts](src/llm/ollama.client.ts)

   - Экспортируется для обратной совместимости
   - Не используется в коде (только экспорт в index.ts)
   - Функционал заменён на `OllamaProvider`

2. Дублирование HTTP-логики между провайдерами:

   - Одинаковая логика сборки chunks в `OllamaProvider` и `OpenAIProvider`
   - Похожая обработка ошибок
   - Повторяющийся парсинг ответов (choices[0].message.content)
   - Одинаковый маппинг usage tokens

3. Несогласованность обработки ошибок:

   - `GroqProvider`: базовая через try-catch
   - `OllamaProvider`: детальная проверка HTTP статусов
   - `OpenAIProvider`: минимальная обработка

4. Жёсткая привязка к Groq для chat:
   ```typescript
   // provider.factory.ts строка 157
   if (operation === "chat") {
     const groq = this.providers.get("groq");
     // ...
   }
   ```


Ограничивает гибкость и тестирование

5. Дублирование промптов:

   - `QuestionParser` и `InteractiveQueryBuilder` содержат похожие системные промпты
   - Изменения требуют правок в нескольких местах

### 2.5. Telegram бот (src/telegram/)

**Структура**:

- [index.ts](src/telegram/index.ts) — **881 строка**, монолитный файл
- `session.store.ts` — PostgreSQL + Memory fallback
- `keyboards.ts` — inline-клавиатуры
- `view.format.ts` — форматирование сообщений
- `text.utils.ts` — утилиты для текста
- `telegram.search.ts` — **НЕ ИСПОЛЬЗУЕТСЯ**
- `category.match.ts` — **НЕ ИСПОЛЬЗУЕТСЯ**

**Проблемы**:

1. Монолитный файл `index.ts`:

   - 881 строка кода
   - Смешаны инициализация, обработчики, бизнес-логика, утилиты
   - Сложно тестировать и поддерживать

2. Дублирование кода в `index.ts`:

   - Повторяющаяся логика сохранения messageIds (2 места)
   - Повторяющаяся логика получения/создания сессии (10+ мест)
   - Повторяющаяся логика удаления сообщений
   - Похожие блоки пагинации для категорий и результатов

3. Мёртвый код:

   - [src/telegram/telegram.search.ts](src/telegram/telegram.search.ts) (~40 строк) — не используется
   - [src/telegram/category.match.ts](src/telegram/category.match.ts) (~80 строк) — не используется

4. Жёстко закодированные значения:

   - Размер страницы категорий: `pageSize = 8` (строка 621)
   - Несогласованность: где-то константа, где-то env

5. Неоптимальная работа с индексом категорий:

   - Индекс пересобирается при каждом запросе категорий
   - Нет кэширования с TTL

### 2.6. Скрипты (src/scripts/)

**Всего**: 30 скриптов

**Классификация**:

- Анализ параметров (4) — полезные
- Генерация словаря (4) — есть дублирование
- Нормализация (2) — полезные
- Тесты (13) — есть дублирование
- Демо (2) — один можно переместить в docs
- Утилиты (4) — один устаревший
- Отладка (1) — полезный

**Проблемы**:

1. Устаревшие скрипты:

   - `seed-parameter-dictionary.ts` — заменён на `seed-parameter-dictionary-complete.ts`
   - `check-equipment-params.ts` — одноразовый с hardcoded моделями

2. Дублирование:

   - `auto-generate-dictionary.ts` + `generate-dictionary.ts` — похожая логика генерации через LLM
   - `test-all-fixes.ts` + `test-security-fixes.ts` — пересекающиеся тесты

3. Использует устаревший код:

   - `test-parameter-search.ts` использует `ParameterNameMapper`

## 3. Критические проблемы

### 3.1. Дублирование кода (Приоритет: Высокий)

**Метрики**:

- Преобразование дат: 99 вхождений в 6 файлах
- Валидация ID: 24 вхождения в 3 файлах
- Password утилиты: 2 идентичных файла
- Создание пула БД: 2 реализации (~100 строк каждая)
- HTTP-логика в LLM: дублируется между 2 провайдерами

**Решение**:

- Создать общие утилиты в `src/api/shared/utils/`
- Удалить дубликаты файлов
- Создать базовый класс для HTTP-провайдеров

### 3.2. Два пула PostgreSQL (Приоритет: Высокий)

**Проблема**:

- Риск перегрузки БД (до 40 соединений)
- Дублирование конфигурации и логики

**Решение**:

- Использовать один пул из `src/db/pg.ts`
- API использует его через `fastify.db` (декоратор)
- Унифицировать конфигурацию

### 3.3. Устаревший код (Приоритет: Средний)

**Файлы на удаление**:

- [src/llm/ollama.client.ts](src/llm/ollama.client.ts) — заменён на OllamaProvider
- [src/normalization/parameter-name-mapper.ts](src/normalization/parameter-name-mapper.ts) — заменён на словарь БД
- [src/telegram/telegram.search.ts](src/telegram/telegram.search.ts) — не используется
- [src/telegram/category.match.ts](src/telegram/category.match.ts) — не используется
- [src/api/shared/utils/password.ts](src/api/shared/utils/password.ts) — дубликат
- [src/scripts/seed-parameter-dictionary.ts](src/scripts/seed-parameter-dictionary.ts) — устарел
- [src/scripts/check-equipment-params.ts](src/scripts/check-equipment-params.ts) — одноразовый

**Итого**: ~700 строк мёртвого кода

### 3.4. Монолитный telegram/index.ts (Приоритет: Средний)

**Проблема**:

- 881 строка в одном файле
- Сложно тестировать
- Дублирование внутри файла

**Решение**:

- Разделить на модули:
  - `handlers/command.handler.ts` — команды
  - `handlers/text.handler.ts` — текстовые сообщения
  - `handlers/callback.handler.ts` — callback_query
  - `services/session.service.ts` — работа с сессиями
  - `utils/message.utils.ts` — отправка/удаление сообщений

### 3.5. Несогласованность интерфейсов (Приоритет: Средний)

**Проблема**:

- Интерфейс `ParameterDictionary` определён 2 раза по-разному
- Разные форматы полей (snake_case vs camelCase)

**Решение**:

- Создать общий интерфейс в `src/shared/types/`
- Использовать единый формат (рекомендуется camelCase)

## 4. Рекомендации по рефакторингу

### Приоритет 1: Критичные исправления

1. **Удалить дубликаты файлов** (1-2 часа)

   - Удалить `src/api/shared/utils/password.ts`
   - Удалить устаревшие скрипты (2 файла)
   - Удалить неиспользуемые модули (4 файла)

2. **Унифицировать подключение к БД** (2-3 часа)

   - Использовать один пул из `src/db/pg.ts`
   - Обновить `databasePlugin` для использования общего пула
   - Обновить `EquipmentRepository` для DI пула

3. **Создать общие утилиты** (2-3 часа)
   ```typescript
   // src/api/shared/utils/date.ts
   export function formatDate(date: Date | string): string
   
   // src/api/shared/utils/validation.ts
   export function parseId(id: string, entityName: string): number
   
   // src/api/shared/utils/pagination.ts
   export function calculatePagination(page?: number, limit?: number)
   
   // src/api/shared/utils/query-builder.ts
   export class UpdateQueryBuilder
   ```


### Приоритет 2: Улучшение архитектуры

4. **Рефакторинг telegram/index.ts** (4-6 часов)

   - Разделить на модули handlers/, services/, utils/
   - Вынести дублирующийся код в утилиты

5. **Унифицировать интерфейсы** (1-2 часа)

   - Создать общий `ParameterDictionary` в `src/shared/types/`
   - Обновить оба модуля для использования общего типа

6. **Рефакторинг LLM провайдеров** (3-4 часа)

   - Создать базовый класс `BaseHTTPProvider`
   - Вынести общую HTTP-логику
   - Удалить `ollama.client.ts`

7. **Оптимизация нормализации** (2-3 часа)

   - Добавить HashMap-индексы для O(1) поиска
   - Реализовать глобальный кэш словаря
   - Удалить `ParameterNameMapper`

### Приоритет 3: Оптимизация

8. **Объединить дублирующиеся скрипты** (2-3 часа)

   - Объединить `auto-generate-dictionary.ts` + `generate-dictionary.ts`
   - Объединить `test-all-fixes.ts` + `test-security-fixes.ts`

9. **Кэширование индекса категорий** (1-2 часа)

   - Добавить TTL-кэш для `CatalogIndexService`

10. **Улучшить типизацию** (1-2 часа)

    - Использовать типы Telegraf вместо `any`
    - Строгая типизация контекстов

## 5. Оценка избыточных зависимостей

### Основные зависимости (необходимые):

- `fastify` + плагины — веб-сервер
- `pg` — PostgreSQL клиент
- `telegraf` — Telegram бот
- `groq-sdk` — LLM провайдер
- `bcrypt` — хэширование паролей
- `jsonwebtoken` — JWT токены
- `sharp` — обработка изображений
- `axios` — HTTP-клиент

### Потенциально избыточные:

- `commander` — используется в CLI, но можно обойтись без библиотеки для простого CLI
- `chalk` — цветной вывод в консоль (nice-to-have)
- `fs-extra` — расширенные файловые операции (можно заменить на fs.promises из Node.js)

### Неиспользуемые (требуют проверки):

- Необходимо проверить использование `commander` и `chalk` через grep
- Если не используются — можно удалить

## 6. Положительные аспекты архитектуры

- ✅ Единообразная структура API модулей
- ✅ Использование TypeScript с strict режимом
- ✅ Централизованная обработка ошибок
- ✅ Разделение на слои (controller → service → repository/db)
- ✅ JSON Schema валидация
- ✅ Swagger документация API
- ✅ Поддержка нескольких LLM провайдеров с fallback
- ✅ Гибридный поиск (FTS + Vector)
- ✅ Система нормализации параметров
- ✅ Graceful fallback для сессий (PostgreSQL → Memory)

## 7. Итоговая статистика

**Размер кодовой базы**:

- Всего файлов: ~125 TypeScript файлов
- Основной код: ~95 файлов
- Скрипты: 30 файлов
- Строк кода: ~15,000-20,000 (оценка)

**Выявленное дублирование**:

- Мёртвый код: ~700 строк (7 файлов)
- Дублирование преобразования дат: 99 вхождений
- Дублирование валидации ID: 24 вхождения
- Дублирование создания пула БД: ~100 строк
- Дублирование HTTP-логики: ~200 строк

**Потенциал сокращения**:

- Удаление мёртвого кода: ~700 строк
- Вынос общих утилит: ~300-500 строк
- **Итого**: можно сократить ~1000-1200 строк кода (~5-6%)

**Время на рефакторинг**:

- Приоритет 1: 5-8 часов
- Приоритет 2: 10-15 часов
- Приоритет 3: 4-7 часов
- **Итого**: 19-30 часов работы

## 8. Краткая версия (Quick Summary)

### Основные проблемы:

1. **Дублирование кода** (~1000 строк)

   - Преобразование дат, валидация ID, пагинация
   - Два файла password.ts
   - HTTP-логика в LLM провайдерах

2. **Два пула PostgreSQL**

   - Риск перегрузки БД (40 соединений)
   - Дублирование конфигурации

3. **Мёртвый код** (~700 строк, 7 файлов)

   - ollama.client.ts, parameter-name-mapper.ts
   - telegram.search.ts, category.match.ts
   - 3 устаревших скрипта

4. **Монолитный telegram бот** (881 строка в одном файле)

   - Сложно поддерживать
   - Внутреннее дублирование

5. **Несогласованность интерфейсов**

   - ParameterDictionary определён дважды по-разному

### Способы решения:

1. **Создать общие утилиты** (2-3 часа)

   - `formatDate()`, `parseId()`, `calculatePagination()`
   - `UpdateQueryBuilder` для динамических UPDATE

2. **Унифицировать БД** (2-3 часа)

   - Один пул из src/db/pg.ts для всех

3. **Удалить мёртвый код** (1-2 часа)

   - 7 файлов на удаление

4. **Разделить telegram/index.ts** (4-6 часов)

   - На handlers/, services/, utils/

5. **Рефакторинг LLM** (3-4 часа)

   - Базовый класс для HTTP-провайдеров
   - Удалить ollama.client.ts

**Итого**: 12-18 часов для устранения критических проблем (Приоритет 1-2)

### Метрики улучшения:

- Сокращение кода: ~5-6% (~1000-1200 строк)
- Улучшение поддерживаемости: значительное (разделение монолитов)
- Снижение нагрузки на БД: 2x (40 → 20 соединений max)
- Устранение технического долга: ~700 строк мёртвого кода